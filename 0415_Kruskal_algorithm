#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODE 50
#define MAX_EDGE 100
#define ONLY_FIND 0
#define UNION 1

typedef struct edge {
    int v1, v2;
    int weight;
} edge;


edge Edge[MAX_EDGE];
int parent[MAX_NODE];
int height[MAX_NODE];
int cost = 0;

int nheap = 0;
int heap[MAX_EDGE];  // 힙에는 Edge의 인덱스를 저장

FILE* fp;

// 이름 → 정수 인덱스
int name2int(char c) {
    return c - 'A';
}

// 정수 인덱스 → 이름
char int2name(int i) {
    return i + 'A';
}

void find_init(int elem) {
    for (int i = 0; i < elem; i++)
        parent[i] = -1;
}

void union_set(int elem, int asso) {
    parent[elem] = asso;
}

int find_set(int elem, int asso, int flag) {
    int i = elem, j = asso;

    while (parent[i] >= 0)
        i = parent[i];
    while (parent[j] >= 0)
        j = parent[j];

    if (flag == UNION && i != j)
        union_set(i, j);

    return (i != j); // 다르면 MST에 포함 가능
}



// 힙 연산
void upheap(int h[], int k) {
    int v = h[k];
    while (k > 1 && Edge[h[k / 2]].weight > Edge[v].weight) {
        h[k] = h[k / 2];
        k /= 2;
    }
    h[k] = v;
}

void downheap(int h[], int k) {
    int v = h[k];
    int j;
    while (k <= nheap / 2) {
        j = 2 * k;
        if (j < nheap && Edge[h[j]].weight > Edge[h[j + 1]].weight)
            j++;
        if (Edge[v].weight <= Edge[h[j]].weight)
            break;
        h[k] = h[j];
        k = j;
    }
    h[k] = v;
}

void pq_init() {
    nheap = 0;
}

void pq_insert(int h[], int v) {
    h[++nheap] = v;
    upheap(h, nheap);
}

int pq_extract(int h[]) {
    int v = h[1];
    h[1] = h[nheap--];
    downheap(h, 1);
    return v;
}

int pq_empty() {
    return (nheap == 0);
}

void visit(int e) {
    printf("%c - %c (weight = %d)\n", int2name(Edge[e].v1), int2name(Edge[e].v2), Edge[e].weight);
    cost += Edge[e].weight;
}

void input_edge(edge e[], int* V, int* E) {
    char vertex[3];
    int w;

    printf("Input number of nodes and edges:\n");
    fscanf(fp, "%d %d", V, E);

    for (int j = 0; j < *E; j++) {
        printf("Input two nodes and weight (e.g., AB 4):\n");
        fscanf(fp, "%s %d", vertex, &w);
        vertex[2] = '\0';

        e[j].v1 = name2int(vertex[0]);
        e[j].v2 = name2int(vertex[1]);
        e[j].weight = w;
    }
}

void kruskal(edge e[], int V, int E) {
    int n = 0, val;
    find_init(V);
    pq_init();

    for (int i = 0; i < E; i++)
        pq_insert(heap, i);

    while (!pq_empty()) {
        val = pq_extract(heap);
        if (find_set(e[val].v1, e[val].v2, UNION)) {
            visit(val);
            n++;
        }
        if (n == V - 1)
            break;
    }
}

int main() {
    int V, E;
    fp = fopen("C:\\Users\\미경\\Downloads\\graph.txt", "rt");
   

    input_edge(Edge, &V, &E);
    printf("\nVisited edges of the minimum spanning tree:\n");
    kruskal(Edge, V, E);
    printf("\nMinimum cost is: %d\n", cost);

    fclose(fp);
    return 0;
}
